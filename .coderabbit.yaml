# CodeRabbit Configuration for oinker
# Docs: https://docs.coderabbit.ai/configuration/

language: en-US
tone_instructions: |
  Invert: Ask "What would make this fail?" not "Is this good?" Be direct.
  Explain failure modes and suggest prevention.

reviews:
  profile: assertive
  collapse_walkthrough: false
  poem: false
  request_changes_workflow: false
  high_level_summary: true
  high_level_summary_placeholder: "@coderabbitai summary"
  abort_on_close: true
  review_status: false

  auto_review:
    enabled: true
    drafts: false
    base_branches:
      - main
    ignore_title_keywords:
      - "WIP"
      - "[WIP]"
      - "DO NOT MERGE"

  path_filters:
    - "!**/__pycache__/**"
    - "!**/.venv/**"
    - "!**/.pytest_cache/**"
    - "!**/.ruff_cache/**"
    - "!**/dist/**"
    - "!**/*.egg-info/**"
    - "!**/htmlcov/**"
    - "!**/.coverage"
    - "!**/uv.lock"

  path_instructions:
    - path: "src/oinker/**/*.py"
      instructions: |
        Oinker: Async-first Porkbun DNS client library. Python 3.13+.

        INVERSION CHECKLIST - What would cause this to fail?

        Architecture failures to prevent:
        - Blocking calls in async functions (use httpx, not requests)
        - Missing context manager cleanup (__aexit__ must close resources)
        - Sync wrappers not using loop.run_until_complete() correctly

        API design failures to prevent:
        - Breaking the async-first pattern (core logic must be async)
        - Inconsistent naming (methods: snake_case, classes: PascalCase)
        - Missing type hints (full annotations required, avoid Any)
        - Pydantic usage (prefer dataclasses with frozen=True, slots=True)

        HTTP/Network failures to prevent:
        - Missing retry logic for transient failures
        - No timeout on HTTP requests
        - Swallowing exceptions instead of re-raising with context
        - Not preserving exception chains (use "from e")

        Validation failures to prevent:
        - Records accepting invalid data (validate in __post_init__)
        - TTL below 600 seconds (Porkbun minimum)
        - Invalid IP addresses passing through

        Exception handling failures to prevent:
        - Generic except clauses hiding real errors
        - Error messages too vague for debugging
        - Not using the OinkerError hierarchy

        Don't nitpick: ruff handles style, ty handles types.

    - path: "src/oinker/_http.py"
      instructions: |
        HTTP layer with retry logic. Critical for reliability.

        INVERSION: What would cause network operations to fail?
        - No exponential backoff on retries
        - Retrying non-idempotent operations
        - Missing timeout configuration
        - Not handling httpx.ConnectError, httpx.TimeoutException
        - Rate limit responses (429) not surfaced as RateLimitError

    - path: "src/oinker/_config.py"
      instructions: |
        Configuration and authentication handling.

        INVERSION: What would cause auth to fail?
        - Credentials not loaded from environment when not provided
        - No validation that both api_key and secret_key are present
        - Sensitive data logged or exposed in exceptions

    - path: "src/oinker/_exceptions.py"
      instructions: |
        Exception hierarchy inheriting from OinkerError.

        INVERSION: What would make error handling fail?
        - Exceptions not inheriting from OinkerError (breaks catch-all)
        - Missing context in error messages
        - RateLimitError without retry_after attribute

    - path: "src/oinker/dns/**/*.py"
      instructions: |
        DNS record management - the core feature.

        INVERSION: What would cause DNS operations to fail?
        - Record dataclasses not validating content on init
        - IPv4/IPv6 addresses not validated
        - ClassVar[DNSRecordType] not set on record classes
        - from_api_response() not handling missing/malformed fields
        - Priority validation missing for MX/SRV records

    - path: "src/oinker/dnssec/**/*.py"
      instructions: |
        DNSSEC record management at the registry level.

        INVERSION: What would cause DNSSEC operations to fail?
        - Not handling registry-specific field requirements
        - from_api_response() not handling dict-keyed records
        - Missing optional key data fields in create request

    - path: "src/oinker/ssl/**/*.py"
      instructions: |
        SSL certificate bundle retrieval.

        INVERSION: What would cause SSL operations to fail?
        - Not handling empty certificate bundles
        - from_api_response() using wrong key names (certificatechain vs certificate_chain)

    - path: "tests/**/*.py"
      instructions: |
        pytest with pytest-asyncio (asyncio_mode = "auto").

        INVERSION: What would make these tests meaningless?
        - Tests that pass but don't assert meaningful outcomes
        - Mocks without spec= (won't catch attribute errors)
        - Missing edge cases: empty responses, network errors, invalid data
        - Not testing both success and failure paths
        - Parameterized tests with boolean flags instead of nullcontext()/pytest.raises()

        Pattern to follow:
        ```python
        @pytest.mark.parametrize(("input", "valid"), [("good", True), ("bad", False)])
        def test_validation(self, input: str, valid: bool) -> None:
            expectation = nullcontext() if valid else pytest.raises(ValidationError)
            with expectation:
                SomeRecord(content=input)
        ```

    - path: "tests/conftest.py"
      instructions: |
        Shared pytest fixtures.

        INVERSION: What would make fixtures unreliable?
        - Fixtures without proper cleanup
        - AsyncMock without spec=httpx.AsyncClient
        - Fixtures returning mutable state shared across tests

    - path: "pyproject.toml"
      instructions: |
        Project configuration. Uses uv, ruff, ty, pytest.

        INVERSION: What would break the build/test cycle?
        - Missing dev dependencies
        - Incompatible version constraints
        - pytest-asyncio missing asyncio_mode = "auto"
        - Coverage excluding important paths

    - path: ".github/workflows/**"
      instructions: |
        CI/CD workflows.

        INVERSION: What would cause CI to give false confidence?
        - Not testing all supported Python versions (3.13, 3.14)
        - Missing typecheck step (ty check)
        - Secrets exposed in logs
        - Caching that hides dependency issues

    - path: "Makefile"
      instructions: |
        Build automation. All commands use "uv run".

        INVERSION: What would make the Makefile unreliable?
        - Missing .PHONY declarations
        - Commands that fail silently
        - Inconsistency between Makefile and CI commands

chat:
  auto_reply: true

knowledge_base:
  learnings:
    scope: global
